# üß™ Contract Testing Guide for Tralalero Contracts

**Purpose**: Complete testing workflow for contracts generated by Tralalero

**When to use**: After generating a contract, before deploying to testnet

---

## üéØ Quick Overview

Your workflow:
```
1. Generate contract with blocks ‚Üí Rust code
2. RUN TESTS ‚Üê You are here
3. Compile to WASM
4. Deploy to testnet
5. Verify on-chain
```

---

## üöÄ Part 1: Running Unit Tests on Generated Contracts

### Step 1: Locate Your Generated Contract

After generation, your contract is at:
```
tralala/dynamic-contracts/{symbol}_{type}_{uuid}/
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ lib.rs          ‚Üê Your contract code
‚îî‚îÄ‚îÄ tests/              ‚Üê Test files (optional)
```

### Step 2: Run Tests

```bash
# Navigate to contract directory
cd tralala/dynamic-contracts/MYTOKEN_simple_abc123/

# Run all tests
cargo test

# Run specific test
cargo test test_transfer

# Run with output
cargo test -- --nocapture

# Run in release mode (faster)
cargo test --release
```

### Step 3: Understand Test Output

```
running 15 tests

test tests::test_mint_increases_balance ... ok
test tests::test_transfer_success ... ok
test tests::test_transfer_insufficient_balance ... ok
test tests::test_burn_decreases_balance ... ok
test tests::test_authorization_required ... ok

test result: ok. 15 passed; 0 failed; 0 ignored

   Compiling my-token v0.1.0
    Finished test [unoptimized + debuginfo] target(s) in 2.34s
```

‚úÖ **Good**: All tests pass
‚ùå **Bad**: Any test fails ‚Üí Fix before compilation

---

## üìù Part 2: Common Test Patterns for Your Generated Contracts

### Pattern 1: Testing Token Initialization

**Your generated contract has**:
```rust
pub fn initialize(admin: Address, name: Symbol, symbol: Symbol, decimals: u32) {
    // ... setup code
}
```

**Test it**:
```rust
#[test]
fn test_initialization() {
    let env = Env::default();
    let admin = Address::generate(&env);

    my_contract.initialize(
        &env,
        &admin,
        symbol_short!("MYTOKEN"),
        symbol_short!("MTK"),
        7,  // 7 decimals like XLM
    );

    // Verify initialization
    assert_eq!(my_contract.name(&env), symbol_short!("MYTOKEN"));
    assert_eq!(my_contract.symbol(&env), symbol_short!("MTK"));
    assert_eq!(my_contract.decimals(&env), 7);
}
```

### Pattern 2: Testing Mint

**Your contract likely has**:
```rust
pub fn mint(to: Address, amount: i128) -> Result<(), ContractError> {
    admin_only()?;
    increase_balance(to, amount)?;
    Ok(())
}
```

**Test it**:
```rust
#[test]
fn test_mint_success() {
    let env = Env::default();
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);

    initialize_contract(&env, &admin);

    // Mint 100 tokens to alice
    my_contract.mint(&env, &alice, 100).unwrap();

    // Verify
    assert_eq!(my_contract.balance_of(&env, &alice), 100);
}

#[test]
fn test_mint_only_admin() {
    let env = Env::default();
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);
    let bob = Address::generate(&env);

    initialize_contract(&env, &admin);

    // Bob (non-admin) tries to mint
    let result = my_contract.mint(&env, &alice, 100);

    // Should fail
    assert!(result.is_err());
    assert_eq!(my_contract.balance_of(&env, &alice), 0);
}
```

### Pattern 3: Testing Transfer

**Your contract has**:
```rust
pub fn transfer(from: Address, to: Address, amount: i128) -> Result<(), ContractError> {
    from.require_auth();
    decrease_balance(&from, amount)?;
    increase_balance(&to, amount)?;
    Ok(())
}
```

**Comprehensive tests**:
```rust
#[test]
fn test_transfer_success() {
    let env = Env::default();
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);
    let bob = Address::generate(&env);

    initialize_contract(&env, &admin);
    my_contract.mint(&env, &alice, 100).unwrap();

    // Alice transfers 50 to Bob
    env.mock_all_auths();
    my_contract.transfer(&env, &alice, &bob, 50).unwrap();

    assert_eq!(my_contract.balance_of(&env, &alice), 50);
    assert_eq!(my_contract.balance_of(&env, &bob), 50);
}

#[test]
fn test_transfer_insufficient_balance() {
    let env = Env::default();
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);
    let bob = Address::generate(&env);

    initialize_contract(&env, &admin);
    my_contract.mint(&env, &alice, 50).unwrap();

    // Alice tries to transfer 100 (she only has 50)
    env.mock_all_auths();
    let result = my_contract.transfer(&env, &alice, &bob, 100);

    assert!(result.is_err());
    assert_eq!(my_contract.balance_of(&env, &alice), 50);  // Unchanged
}

#[test]
fn test_transfer_zero_amount() {
    let env = Env::default();
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);
    let bob = Address::generate(&env);

    initialize_contract(&env, &admin);
    my_contract.mint(&env, &alice, 100).unwrap();

    env.mock_all_auths();
    let result = my_contract.transfer(&env, &alice, &bob, 0);

    assert!(result.is_err(), "Zero transfers not allowed");
}
```

### Pattern 4: Testing Burn

```rust
#[test]
fn test_burn_success() {
    let env = Env::default();
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);

    initialize_contract(&env, &admin);
    my_contract.mint(&env, &alice, 100).unwrap();

    env.mock_all_auths();
    my_contract.burn(&env, &alice, 30).unwrap();

    assert_eq!(my_contract.balance_of(&env, &alice), 70);
    assert_eq!(my_contract.total_supply(&env), 70);
}

#[test]
fn test_burn_insufficient_balance() {
    let env = Env::default();
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);

    initialize_contract(&env, &admin);
    my_contract.mint(&env, &alice, 50).unwrap();

    env.mock_all_auths();
    let result = my_contract.burn(&env, &alice, 100);

    assert!(result.is_err());
    assert_eq!(my_contract.balance_of(&env, &alice), 50);
}
```

### Pattern 5: Testing Pausable (if enabled)

```rust
#[test]
fn test_pause_prevents_transfers() {
    let env = Env::default();
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);
    let bob = Address::generate(&env);

    initialize_contract(&env, &admin);
    my_contract.mint(&env, &alice, 100).unwrap();

    // Pause the contract
    env.mock_all_auths();
    my_contract.pause(&env).unwrap();

    // Try to transfer - should fail
    let result = my_contract.transfer(&env, &alice, &bob, 50);

    assert!(result.is_err(), "Transfers not allowed when paused");
}

#[test]
fn test_unpause_allows_transfers() {
    let env = Env::default();
    let admin = Address::generate(&env);
    let alice = Address::generate(&env);
    let bob = Address::generate(&env);

    initialize_contract(&env, &admin);
    my_contract.mint(&env, &alice, 100).unwrap();

    env.mock_all_auths();
    my_contract.pause(&env).unwrap();
    my_contract.unpause(&env).unwrap();

    // Now transfer should work
    let result = my_contract.transfer(&env, &alice, &bob, 50);

    assert!(result.is_ok());
}
```

---

## üîß Part 3: Testing Tralalero-Generated Contracts

### Testing Your Specific Generated Contract

Each contract type has different features. Here's how to test them:

#### Token with Mint

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use soroban_sdk::testutils::Address;

    fn setup() -> (Env, Address) {
        let env = Env::default();
        let admin = Address::generate(&env);
        let contract_id = env.register_contract(None, Contract);

        // Initialize
        env.invoke_contract(&contract_id, &symbol_short!("init"), ());

        (env, admin)
    }

    #[test]
    fn test_full_token_lifecycle() {
        let (env, admin) = setup();

        // 1. Verify initialization
        let name = get_name(&env);
        assert_eq!(name, symbol_short!("MYTOKEN"));

        // 2. Mint tokens
        mint(&env, &admin, 1000);
        assert_eq!(balance_of(&env, &admin), 1000);

        // 3. Transfer
        let alice = Address::generate(&env);
        transfer(&env, &admin, &alice, 100);
        assert_eq!(balance_of(&env, &alice), 100);

        // 4. Burn
        burn(&env, &admin, 50);
        assert_eq!(balance_of(&env, &admin), 850);

        // 5. Verify total supply
        assert_eq!(total_supply(&env), 1000 - 50);
    }
}
```

#### Token with Staking

```rust
#[test]
fn test_staking_flow() {
    let env = Env::default();
    let user = Address::generate(&env);

    // Mint tokens
    mint(&env, &user, 1000);

    // Stake 500 tokens
    stake(&env, &user, 500).unwrap();

    // Verify staked balance
    assert_eq!(staked_balance(&env, &user), 500);
    assert_eq!(balance_of(&env, &user), 500);  // 1000 - 500

    // Fast forward time
    env.ledger().with_mut(|l| {
        l.sequence_number += 100;  // ~8 minutes later
    });

    // Claim rewards
    let rewards = claim_rewards(&env, &user).unwrap();
    assert!(rewards > 0, "Should have rewards");
}
```

---

## üîç Part 4: Debugging Failed Tests

### Problem: "assertion failed"

```
test tests::test_transfer ... FAILED

thread 'tests::test_transfer' panicked at 'assertion failed: `(left == right)`
  left: `100`,
 right: `50`', src/lib.rs:234:5
```

**Solution**:
1. Check your logic - are you calculating correctly?
2. Add debugging:
   ```rust
   println!("Expected: {}, Got: {}", expected, actual);
   ```
3. Run with output:
   ```bash
   cargo test test_transfer -- --nocapture
   ```

### Problem: "thread panicked at 'Attempting to... without authorization'"

**Cause**: Missing `env.mock_all_auths()`

**Solution**:
```rust
#[test]
fn test_something() {
    env.mock_all_auths();  // Add this line
    my_contract.transfer(&env, &alice, &bob, 50).unwrap();
}
```

### Problem: "cannot find function in this scope"

**Cause**: Using wrong import or function name

**Solution**:
```rust
use super::*;  // Make sure this is at top of tests module
use soroban_sdk::testutils::Address;
```

### Problem: "type mismatch"

**Cause**: Wrong types

```
error[E0308]: mismatched types
  expected `i128`
     found `u32`
```

**Solution**:
```rust
// Wrong
let amount: u32 = 100;
my_contract.transfer(&env, &alice, &bob, amount);

// Right
let amount: i128 = 100;
my_contract.transfer(&env, &alice, &bob, amount);
```

---

## üìä Part 5: Test Coverage Report

### Generating Coverage

```bash
# Install tarpaulin (coverage tool)
cargo install cargo-tarpaulin

# Run coverage
cargo tarpaulin --out Html --output-dir coverage

# View report
open coverage/index.html
```

### Coverage Goals

| Function Type | Minimum | Goal |
|---------------|---------|------|
| Public functions | 80% | 95%+ |
| Error paths | 100% | 100% |
| Authorization | 100% | 100% |
| Transfer logic | 95%+ | 100% |
| State changes | 90%+ | 100% |

---

## ‚úÖ Part 6: Pre-Compilation Testing Checklist

Before running `cargo build --release --target wasm32-unknown-unknown`:

### Functional Tests
- [ ] Initialize contract successfully
- [ ] Mint tokens
- [ ] Transfer tokens
- [ ] Check balances
- [ ] Burn tokens (if enabled)

### Authorization Tests
- [ ] Only admin can mint
- [ ] Only owner can transfer
- [ ] Unauthorized calls fail

### Edge Cases
- [ ] Zero amount transfer (should fail)
- [ ] Negative amount (should fail)
- [ ] Transfer to self (optional behavior)
- [ ] Large amounts (near i128::MAX)

### State Consistency
- [ ] Total supply correct
- [ ] All balances sum to total supply
- [ ] No balance changes on failed transfers

### Error Handling
- [ ] Insufficient balance errors
- [ ] Authorization errors
- [ ] Invalid amount errors

---

## üöÄ Part 7: Full Testing Example (Complete Token)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use soroban_sdk::testutils::Address;

    fn init_contract() -> (Env, Address, Address, Address) {
        let env = Env::default();
        let admin = Address::generate(&env);
        let alice = Address::generate(&env);
        let bob = Address::generate(&env);

        let contract_id = env.register_contract(None, Contract);

        // Initialize
        env.invoke_contract(
            &contract_id,
            &symbol_short!("init"),
            (
                admin.clone(),
                symbol_short!("MYTOKEN"),
                symbol_short!("MTK"),
                7u32,
            ),
        );

        (env, admin, alice, bob)
    }

    #[test]
    fn test_1_initialization() {
        let (env, admin, _, _) = init_contract();

        assert_eq!(name(&env), symbol_short!("MYTOKEN"));
        assert_eq!(symbol(&env), symbol_short!("MTK"));
        assert_eq!(decimals(&env), 7);
    }

    #[test]
    fn test_2_mint() {
        let (env, admin, alice, _) = init_contract();

        env.mock_all_auths();
        mint(&env, &alice, 1000).unwrap();

        assert_eq!(balance_of(&env, &alice), 1000);
        assert_eq!(total_supply(&env), 1000);
    }

    #[test]
    fn test_3_transfer() {
        let (env, admin, alice, bob) = init_contract();

        env.mock_all_auths();
        mint(&env, &alice, 1000).unwrap();
        transfer(&env, &alice, &bob, 300).unwrap();

        assert_eq!(balance_of(&env, &alice), 700);
        assert_eq!(balance_of(&env, &bob), 300);
    }

    #[test]
    fn test_4_burn() {
        let (env, admin, alice, _) = init_contract();

        env.mock_all_auths();
        mint(&env, &alice, 1000).unwrap();
        burn(&env, &alice, 200).unwrap();

        assert_eq!(balance_of(&env, &alice), 800);
        assert_eq!(total_supply(&env), 800);
    }

    #[test]
    fn test_5_insufficient_balance() {
        let (env, admin, alice, bob) = init_contract();

        env.mock_all_auths();
        mint(&env, &alice, 100).unwrap();

        let result = transfer(&env, &alice, &bob, 200);
        assert!(result.is_err());
    }

    #[test]
    fn test_6_authorization() {
        let (env, admin, alice, bob) = init_contract();

        // Don't mock auths - only alice is authorized
        // This should fail without proper auth
        let result = transfer(&env, &alice, &bob, 50);

        // Behavior depends on your contract
        // Usually panics or returns error
    }
}
```

---

## üéì Part 8: Testing Your Tralalero Workflow

### Full Integration Test

```bash
# 1. Generate contract (via UI or CLI)
# Contract at: tralala/dynamic-contracts/MYTOKEN_simple_abc123/

# 2. Navigate to contract
cd tralala/dynamic-contracts/MYTOKEN_simple_abc123/

# 3. Run tests
cargo test

# 4. Check output
# ‚úÖ All tests pass? Continue
# ‚ùå Tests fail? Fix contract logic

# 5. Compile
cargo build --release --target wasm32-unknown-unknown

# 6. Check WASM
ls -lh target/wasm32-unknown-unknown/release/

# 7. Deploy (via API or CLI)
curl -X POST http://localhost:3000/api/deploy-contract \
  -H "Content-Type: application/json" \
  -d '{
    "contractPath": "tralala/dynamic-contracts/MYTOKEN_simple_abc123",
    "userAddress": "GXXXXXX..."
  }'

# 8. Verify on testnet
# (/deploy-helper for verification)
```

---

## üìö Related Resources

**In This Project**:
- `/soroban-helper` - Contract patterns & SDK usage
- `/security-checklist` - Security audit before deploy
- `/deploy-helper` - Deployment & testnet verification
- `/debug-testing` - General debugging strategies
- `.claude/skills/testing-soroban-patterns.md` - Advanced patterns

**External**:
- [Soroban Testing Docs](https://soroban.stellar.org/docs/learn/testing)
- [soroban-sdk testutils](https://docs.rs/soroban-sdk/latest/soroban_sdk/testutils/)
- [Rust Testing Book](https://doc.rust-lang.org/book/ch11-00-testing.html)

---

## üí° Pro Tips

1. **Test Early**: Run tests immediately after generation
2. **Test Often**: After each change, run `cargo test`
3. **Test Thoroughly**: Test error cases, not just happy path
4. **Test Independently**: Each test should work alone
5. **Mock Carefully**: Use `env.mock_all_auths()` for authorization tests
6. **Name Clearly**: Test names should explain what they test
7. **Keep It Simple**: One assertion per test when possible
8. **Run Specific Tests**: `cargo test test_transfer` for quick iteration

---

## ‚ö†Ô∏è Common Issues

| Issue | Solution |
|-------|----------|
| Tests compile but fail | Check your contract logic |
| "Cannot find X" error | Add `use super::*;` at top of tests |
| Authorization tests panic | Add `env.mock_all_auths();` before auth-required calls |
| Type mismatch error | Verify types match (i128 for amounts, Address for accounts) |
| Tests timeout | Contract logic might be infinite loop |

---

**Last Updated**: November 2, 2025
**Use with**: `/soroban-helper`, `/security-checklist`, `/deploy-helper`
**Skill**: `.claude/skills/testing-soroban-patterns.md`
